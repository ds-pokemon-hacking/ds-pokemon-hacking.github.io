"use strict";(self.webpackChunkkodsh_wiki_new=self.webpackChunkkodsh_wiki_new||[]).push([[48],{9107:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/block_select-027de52d920fe0dc0340b4ed550bb9da.png"},28453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>r});var n=i(96540);const s={},o=n.createContext(s);function l(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(o.Provider,{value:t},e.children)}},31892:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/arm9_expansion-f27da3759839f304b152ddf9c5ee9c87.png"},55291:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>g,contentTitle:()=>f,default:()=>j,frontMatter:()=>x,metadata:()=>n,toc:()=>m});const n=JSON.parse('{"id":"generation-iv/guides/pt-type_expansion/pt-type_expansion","title":"Type Expansion","description":"Author: Yako","source":"@site/docs/generation-iv/guides/pt-type_expansion/pt-type_expansion.md","sourceDirName":"generation-iv/guides/pt-type_expansion","slug":"/generation-iv/guides/pt-type_expansion/","permalink":"/docs/generation-iv/guides/pt-type_expansion/","draft":false,"unlisted":false,"editUrl":"https://github.com/ds-pokemon-hacking/ds-pokemon-hacking.github.io/docs/generation-iv/guides/pt-type_expansion/pt-type_expansion.md","tags":[{"inline":true,"label":"Guide (Platinum)","permalink":"/docs/tags/guide-platinum"}],"version":"current","frontMatter":{"title":"Type Expansion","tags":["Guide (Platinum)"]},"sidebar":"generation_iv_sidebar","previous":{"title":"Optimizing and Expanding Functionality for Trainer Pokemon","permalink":"/docs/generation-iv/guides/pt-trainer_code_expansion/"},"next":{"title":"Changing the HP bar Speed","permalink":"/docs/generation-iv/guides/pt_hgss-hp_bar_speed/"}}');var s=i(74848),o=i(28453);const l=i.p+"assets/images/battle_no_sprite-197314baa4f00888d9f68d1a90986460.png",r=i.p+"assets/images/summary_no_sprite-0c0032ac75093bb911df56d3701dbd81.png",a=i.p+"assets/images/dex_no_sprite-1397c75551994cb242f7e0062b96760a.png",h=i.p+"assets/images/nitro_paint_1-5828a654879d2c72a765ddd6f7f7ac15.png",d=i.p+"assets/images/nitro_paint_2-42612b43c2990a27612b5b48d2b5a67e.png",c=i.p+"assets/images/nitro_paint_3-58ae451b7178703be96a65c69f398ed6.png",p=i.p+"assets/images/battle_fairy-8427137d1852e79e5b50f978227ce29c.png",y=i.p+"assets/images/summary_fairy-89157cae4e4c3669fce25ef61e2e34a9.png",u=i.p+"assets/images/dex_fairy-e2b70c5936690731f965484ced30ade3.png",x={title:"Type Expansion",tags:["Guide (Platinum)"]},f="Type Expansion(Platinum)",g={},m=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Lite Version",id:"lite-version",level:2},{value:"Tools used:",id:"tools-used",level:3},{value:"Making space for the new type chart",id:"making-space-for-the-new-type-chart",level:3},{value:"Editing the type chart",id:"editing-the-type-chart",level:3},{value:"Using the <code>type_chart_helper.py</code> script",id:"using-the-type_chart_helperpy-script",level:4},{value:"Assigning new types to moves and Pok\xe9mon",id:"assigning-new-types-to-moves-and-pok\xe9mon",level:3},{value:"Adding sprites",id:"adding-sprites",level:3},{value:"Type Icon",id:"type-icon",level:4},{value:"Move Selection Palette",id:"move-selection-palette",level:3},{value:"Pok\xe9dex Type Icon",id:"pok\xe9dex-type-icon",level:3},{value:"Modifying the game&#39;s code to show the Pok\xe9dex icon",id:"modifying-the-games-code-to-show-the-pok\xe9dex-icon",level:3},{value:"Advanced Version",id:"advanced-version",level:2},{value:"Tools used:",id:"tools-used-1",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Setting up the armips script",id:"setting-up-the-armips-script",level:3},{value:"Adding new types",id:"adding-new-types",level:3},{value:"Assigning new types to moves and Pok\xe9mon",id:"assigning-new-types-to-moves-and-pok\xe9mon-1",level:3},{value:"Not (yet) covered in this guide",id:"not-yet-covered-in-this-guide",level:2}];function w(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsxs)(t.h1,{id:"type-expansionplatinum",children:["Type Expansion",(0,s.jsx)("sup",{children:(0,s.jsx)(t.em,{children:"(Platinum)"})})]})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Author: Yako ",(0,s.jsx)("br",{}),"\nPrevious implementations: Mikelan98 and BagBoy (",(0,s.jsx)(t.a,{href:"https://pokehacking.com/tutorials/fairypt/",children:"Original guide"})," to fairy type), Drayano (",(0,s.jsx)(t.a,{href:"https://pastebin.com/hTeS5EkD",children:"Another guide"})," to fairy type) ",(0,s.jsx)("br",{}),"\nCredits: Mikelan98 and Nomura (ARM9 Expansion), the entire DSPRE team and everyone who worked on pokeplatinum"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["This is a tutorial on how to expand the types available in Platinum. This includes but is not limited to the addition of the Fairy type.\nThis ",(0,s.jsx)(t.strong,{children:"only works on the US Version of the game"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["This guide is split into two versions: A ",(0,s.jsx)(t.strong,{children:"lite version"})," that replaces the existing Mystery type (also known as ??? type) with the Fairy type, and an ",(0,s.jsx)(t.strong,{children:"advanced version"})," that sets up an environment that allows you to add multiple new types, including Fairy, without replacing any existing type.\nI want to preface this guide by saying that even just replacing existing types is a very complex process, and it is not recommended for beginners. It requires a lot of knowledge about hex editing, spriting and the inner workings of the game. You will need to be comfortable using a hex editor, adding and modifying sprites, working with Nitro Paint as well as using DSPRE. The advanced version requires a basic understanding of armips and ASM code, but you won't need to write any ASM code yourself. If you are not comfortable with these things, I recommend you start with the lite version of this guide."]}),"\n",(0,s.jsx)(t.p,{children:"This guide was only possible thanks to the work of Mikelan98 and BagBoy, who created the original Fairy type implementation for Platinum, which served as a starting point for this guide. I also want to thank everyone who worked on pokeplatinum, I am heavily relying on their work for this guide."}),"\n",(0,s.jsxs)(t.p,{children:["Before you start: In addition to this guide I have created a  a folder with a couple of helpful files which is available ",(0,s.jsx)(t.a,{href:"https://drive.google.com/file/d/10Ozf26GwUvjnUmsjasIDODuxoTa6RLNk/view?usp=sharing",children:"here"}),'. Throughout this guide I will refer to these files as the "resources folder". The resources folder contains:']}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A readme file which you should read before starting"}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"type_expansion_PLAT.asm"})," armips script"]}),"\n",(0,s.jsx)(t.li,{children:"All python scripts mentioned in this guide"}),"\n",(0,s.jsx)(t.li,{children:"Images / Sprite resources used in this guide"}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#type-expansion",children:"Type Expansion"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#table-of-contents",children:"Table of Contents"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#lite-version",children:"Lite Version"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#tools-used",children:"Tools used:"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#making-space-for-the-new-type-chart",children:"Making space for the new type chart"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#editing-the-type-chart",children:"Editing the type chart"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#assigning-new-types-to-moves-and-pok%C3%A9mon",children:"Assigning new types to moves and Pok\xe9mon"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#adding-sprites",children:"Adding sprites"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#advanced-version",children:"Advanced Version"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#prerequisites",children:"Prerequisites"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#setting-up-the-armips-script",children:"Setting up the armips script"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#adding-new-types",children:"Adding new types"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#assigning-new-types-2",children:"Assigning new types to moves and Pok\xe9mon"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#not-yet-covered-in-this-guide",children:"Not (yet) covered in this guide"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"lite-version",children:"Lite Version"}),"\n",(0,s.jsx)(t.p,{children:"This version replaces the existing Mystery type with the Fairy type. It is a simpler version of the advanced version, but it still requires some knowledge of hex editing and spriting as well as a basic understanding of DSPRE."}),"\n",(0,s.jsx)(t.h3,{id:"tools-used",children:"Tools used:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/Mixone-FinallyHere/DS-Pokemon-Rom-Editor/releases",children:"DSPRE"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/Garhoogin/NitroPaint/releases",children:"Nitro Paint"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://mh-nexus.de/en/downloads.php?product=HxD",children:"HxD"})," (or any other hex editor)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://www.python.org/downloads/",children:"Python"})," - Or install from the Microsoft Store (optional, for the type chart and palette helper scripts)"]}),"\n",(0,s.jsxs)(t.li,{children:["The resources folder belonging to this guide which can be found ",(0,s.jsx)(t.a,{href:"https://drive.google.com/file/d/10Ozf26GwUvjnUmsjasIDODuxoTa6RLNk/view?usp=sharing",children:"here"})]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"making-space-for-the-new-type-chart",children:"Making space for the new type chart"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Before you start, make a backup of your ROM!"})," ",(0,s.jsx)("br",{}),"\nFirst make sure you have the ARM9 expansion patch applied to your ROM. If you don't have it, you can apply it using DSPRE's toolbox."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"ARM9 Expansion Patch in DSPRE",src:i(31892).A+"",width:"1520",height:"686"})}),"\n",(0,s.jsx)(t.p,{children:"We will take advantage of the newly available space by repointing the move effect subscript table to a different location. The reason we do this is a practical one: repointing this table is much simpler than repointing the type chart itself. Since the type chart is located just before the this table, it will create ample space for us to modify the type chart without having to repoint it."}),"\n",(0,s.jsxs)(t.p,{children:["Next you will need to actually move the move effect subscript table to a different location. Open up your extracted folder generated by DSPRE and go to the ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents/overlay/"})," folder. Inside, you will find a file called ",(0,s.jsx)(t.code,{children:"overlay_0016.bin"}),". Open it in a hex editor (I recommend HxD) and navigate to the offset ",(0,s.jsx)(t.code,{children:"0x33CE4"}),". HxD can do this with the shortcut ",(0,s.jsx)(t.code,{children:"Ctrl + G"})," by default. The beginning of the table should look like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"00 00 00 00 12 00 00 00 16 00 00 00 19 00 00 00 ...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In total this table is a whole 0x244 (= 580) bytes long. Select the entire table and copy it to the clipboard.\nIn HxD, you can do this by pressing ",(0,s.jsx)(t.code,{children:"Ctrl + E"})," which will bring up a block selection menu. Your start offset should be ",(0,s.jsx)(t.code,{children:"0x33CE4"})," and the length should be ",(0,s.jsx)(t.code,{children:"0x244"}),".\nKeep your hex editor and this file open, as we will need it again later."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Copying the move effect subscript table in HxD",src:i(9107).A+"",width:"293",height:"313"})}),"\n",(0,s.jsxs)(t.p,{children:["Next navigate to ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents/unpacked/synthOverlay/"}),". Open the file called ",(0,s.jsx)(t.code,{children:"0009"})," in your hex editor. This file is your synthetic overlay. If you haven't applied the ARM9 expansion before, this file will be empty. Otherwise, it may contain some data. Make sure not to accidentally overwrite any existing data, as it will most likely prevent your game from functioning properly."]}),"\n",(0,s.jsxs)(t.p,{children:["We will now move the move effect subscript table to a location in this file. I recommend using the offset ",(0,s.jsx)(t.code,{children:"0x1000"})," for this, simply because it is a nice round number and it is far enough away from the beginning of the file, making it unlikely that you will overwrite any existing data. Double check to make sure that this offset is actually empty before proceeding. You can do this by block selecting the next 0x244 (= 580) bytes and checking if they are all zeroes. ",(0,s.jsx)("br",{}),"\n(This location isn't empty for you? You can put it somewhere else, but make sure to adjust the pointer accordingly later on. If you don't know how to do this, I recommend asking for help on discord.) ",(0,s.jsx)("br",{}),"\nPaste the move effect subscript table into this file without changing the file's length. In HxD, you can do this by pressing ",(0,s.jsx)(t.code,{children:"Ctrl + B"}),". Make sure to save the file after pasting the data."]}),"\n",(0,s.jsxs)(t.p,{children:["The table is now in its new location, however, we still need to tell the game where to find it. To do this, we will need to modify the pointer to the move effect subscript table.\nOur table is now located at ",(0,s.jsx)(t.code,{children:"0x1000"})," in the synthetic overlay, which is loaded at address ",(0,s.jsx)(t.code,{children:"0x023C8000"})," in memory. Because of this, our new pointer will be ",(0,s.jsx)(t.code,{children:"0x023C9000 = 0x023C8000 + 0x1000"}),".\nThe game uses little-endian format, so we will need to write this pointer in reverse order. In hex, this is ",(0,s.jsx)(t.code,{children:"00 90 3C 02"}),".\nNavigate to the offset ",(0,s.jsx)(t.code,{children:"0x204F8"})," in the ",(0,s.jsx)(t.code,{children:"overlay_0016.bin"})," file. You should see ",(0,s.jsx)(t.code,{children:"24 EE 26 02"}),". Select and replace these four bytes with ",(0,s.jsx)(t.code,{children:"00 09 3C 02"}),". Don't forget to save the file after making this change."]}),"\n",(0,s.jsx)(t.p,{children:"At this point I strongly advice you save your ROM in DSPRE and test it to make sure it actually still works. Get in a battle and use a move (preferably one that has an effect beyond just dealing damage) to make sure the game doesn't crash. If it does or you see weird graphical glitches, you probably made a mistake somewhere. If it doesn't, congratulations! You have successfully moved the move effect subscript table to a new location."}),"\n",(0,s.jsx)(t.h3,{id:"editing-the-type-chart",children:"Editing the type chart"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we have made space for the new type chart, we can actually edit it. This section will guide you through the process of editing the type chart using a hex editor, explaining how the type chart works and how to add new types or change existing types along the way. If you know how to run a python script, you can use the file ",(0,s.jsx)(t.code,{children:"type_chart_helper.py"})," which is included in the accompanying resources folder. It will generate the triplets for you by reading a csv as input. A template csv with mystery type replaced by fairy type and the modern steel type changes is included in the resources folder as well. If you decide to go this route, I recommend you read through this section anyway, as it will help you understand how the type chart works and how it is actually structured in the ROM."]}),"\n",(0,s.jsxs)(t.p,{children:["The type chart is located at the offset ",(0,s.jsx)(t.code,{children:"0x33B94"})," in ",(0,s.jsx)(t.code,{children:"overlay_0016.bin"}),". Open this file in your hex editor and navigate to this offset. You should see a table that looks like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"00 05 05 00 08 05 0A 0A 05 ...\n"})}),"\n",(0,s.jsx)(t.p,{children:"The table is 0x150 (= 336) bytes long and contains the type effectiveness multipliers for each type against every other type. It consists of a series of triplets that have the following structure:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Attacking Type"}),(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Defending Type"}),(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Multiplier"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Byte A"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Byte D"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Byte M"})]})})]}),"\n",(0,s.jsx)(t.p,{children:"The first byte (Byte A) is the attacking type, the second byte (Byte D) is the defending type and the third byte (Byte M) is the multiplier. The multiplier M is equal to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"0x0"})," (= 0) for no effect"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"0x5"})," (= 5) for not very effective"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"0xA"})," (= 10) for normally effective"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"0x14"})," (= 20) for super effective"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["In damage calculations, these multipliers are divided by 10, so 0x5 becomes 0.5, 0xA becomes 1.0 and 0x14 becomes 2.0.\nTo determine effectiveness, the game will go trough this table trying to find a match for the attacking type and the defending type. If it finds a match, it will use the multiplier to calculate the damage dealt. If it doesn't find a match, it will ",(0,s.jsx)(t.strong,{children:"default to 1.0"})," (normal effectiveness)."]}),"\n",(0,s.jsxs)(t.p,{children:["At the end there is a set of three spacer bytes (",(0,s.jsx)(t.code,{children:"0xFE 0xFE 0x00"}),") followed by the ghost type immunities. It's important that you preserve these bytes, as otherwise moves like foresight and odour sleuth will not work properly. After the ghost type immunities, there is a set of three bytes that mark the end of the type chart (",(0,s.jsx)(t.code,{children:"0xFF 0xFF 0x00"}),")."]}),"\n",(0,s.jsx)(t.p,{children:"To add a new type or change an existing type we can insert new triplets into this table, modify the existing triplets or remove existing triplets. If you want to add a new type, you will need to add a new triplet for each type it is effective against, as well as triplets for each type that resists it or is immune to it. Make sure to add the triplets before the spacer bytes. Also keep in mind that duplicate triplets will be ignored, only the first match will be used."}),"\n",(0,s.jsx)(t.p,{children:"Before we can edit the type chart, we will also need the list of the type's IDs:"}),"\n",(0,s.jsx)("a",{id:"type-ids"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Type Name"}),(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Type ID"}),(0,s.jsx)(t.th,{style:{textAlign:"center"},children:"Type ID (Decimal)"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Normal"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x00"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Fighting"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x01"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Flying"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x02"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"2"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Poison"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x03"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"3"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Ground"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x04"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"4"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Rock"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x05"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"5"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Bug"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x06"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"6"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Ghost"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x07"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"7"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Steel"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x08"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"8"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Mystery"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x09"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"9"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Fire"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x0A"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"10"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Water"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x0B"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"11"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Grass"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x0C"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"12"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Electric"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x0D"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"13"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Psychic"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x0E"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"14"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Ice"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x0F"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"15"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Dragon"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x10"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"16"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"Dark"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"0x11"}),(0,s.jsx)(t.td,{style:{textAlign:"center"},children:"17"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Simply modifying the type chart is actually sufficient to have a functional fairy type in the game, however, it will still display as the mystery type in battle, in the menu and in the Pok\xe9dex.\nWe also need to assign the type to the desired moves and Pok\xe9mon."}),"\n",(0,s.jsxs)(t.h4,{id:"using-the-type_chart_helperpy-script",children:["Using the ",(0,s.jsx)(t.code,{children:"type_chart_helper.py"})," script"]}),"\n",(0,s.jsxs)(t.p,{children:["If you want to use the ",(0,s.jsx)(t.code,{children:"type_chart_helper.py"})," script, you will need to have Python installed on your computer. You can download it from ",(0,s.jsx)(t.a,{href:"https://www.python.org/downloads/",children:"here"}),". Alternatively, you can install it from the Microsoft Store, which is the easiest way to get it on Windows. At the top of the file you will find the settings for the script. You will need to provide the path to your overlay 16 file, the path may be something like ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents/unpacked/overlay/overlay_0016.bin"}),". There is also a ",(0,s.jsx)(t.code,{children:"mode"})," setting which can be set to either ",(0,s.jsx)(t.code,{children:"bin-to-csv"})," or ",(0,s.jsx)(t.code,{children:"csv-to-bin"}),". The first mode will convert the binary type chart to a CSV file, while the second mode will convert a CSV file to a binary type chart and write it to your overlay. The script will create a new file called ",(0,s.jsx)(t.code,{children:"type_chart.csv"})," in the same folder as the script. If you plan on adding new types, you can also add them to the enum at the top of the file. The resources folder contains a template CSV file for the modern type chart with the Fairy type replacing the Mystery type calles ",(0,s.jsx)(t.code,{children:"modern_type_chart.csv"}),". You can use this as a starting point for your own type chart or just copy it as is. The folder also contains a copy of the vanilla type chart called ",(0,s.jsx)(t.code,{children:"vanilla_type_chart.csv"})," which you can use to revert your changes if needed."]}),"\n",(0,s.jsx)(t.h3,{id:"assigning-new-types-to-moves-and-pok\xe9mon",children:"Assigning new types to moves and Pok\xe9mon"}),"\n",(0,s.jsxs)(t.p,{children:["To do this we can simply use DSPRE. Open your ROM in DSPRE and go to ",(0,s.jsx)(t.em,{children:"Other Editors"})," > ",(0,s.jsx)(t.em,{children:"Pok\xe9mon Editor"}),". Select the Pok\xe9mon you want to assign the new type to and select it from the ",(0,s.jsx)(t.em,{children:"Types"})," dropdown.\nYou can also assign the new type to moves in the ",(0,s.jsx)(t.em,{children:"Move Editor"})," in the same way. Make sure to save your changes after assigning the new type to the desired Pok\xe9mon and moves. In our case the Fairy type replaces the Mystery type, so that's the type we need to select. You can also edit text archive 624 to change the name of the type to Fairy. This is not strictly necessary however."]}),"\n",(0,s.jsx)(t.p,{children:"For the sake of this guide, I am assigning Clefairy the Fairy type and also changing the type of Charm and Moonlight. In game this will look like this:"}),"\n","\n",(0,s.jsxs)("div",{className:"image-container",children:[(0,s.jsx)("img",{src:l,alt:"Modified Clefairy in battle",width:300,style:{verticalAlign:"top"}}),(0,s.jsx)("img",{src:r,alt:"Modified Clefairy in summary",width:300,style:{verticalAlign:"top"}}),(0,s.jsx)("img",{src:a,alt:"Modified Clefairy in Pok\xe9dex",width:300,style:{verticalAlign:"top"}})]}),"\n",(0,s.jsx)(t.h3,{id:"adding-sprites",children:"Adding sprites"}),"\n",(0,s.jsx)(t.p,{children:"In total we will need to add 3 things: A sprite for the type icon, a sprite for the type in the Pok\xe9dex and a palette used by the move selection in battle. The first two can be done using DSPRE and Nitro Paint, while the third one requires some hex editing.\nI recommend you make a temporary workspace folder that you can use to store some extracted files and sprites."}),"\n",(0,s.jsx)(t.h4,{id:"type-icon",children:"Type Icon"}),"\n",(0,s.jsxs)(t.p,{children:["Let's take care of the easiest one first: the type icon. Open your ROM in DSPRE and select ",(0,s.jsx)(t.em,{children:"Tools"})," > ",(0,s.jsx)(t.em,{children:"NARC Utility"})," > ",(0,s.jsx)(t.em,{children:"Unpack to Folder"}),". (You can also use the button in the bar at the top.)\nWhen promted, select ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents/data/battle/graphic/pl_batt_obj.narc"})," as the NARC file and unpack it to your workspace folder. This will create a new folder called ",(0,s.jsx)(t.code,{children:"pl_battle_obj"}),' in your workspace folder. When asked if you want to rename the files, select "Yes". This will make it easier to find the files later on.']}),"\n",(0,s.jsxs)(t.p,{children:["The type icons consist of four files: a palette file (",(0,s.jsx)(t.code,{children:"0074.rlcn"}),"), the icon itself (for mystery type this is ",(0,s.jsx)(t.code,{children:"0236.rgcn"}),") and a cell resource as well as an animation which we will refrain from touching.\nYou can drag both the palette file and the icon file into Nitro Paint to open them. The palette file contains the colors used by the icon, while the icon file contains the actual sprite.\nIf you want to make your own icon, some basic knowledge of Nitro Paint and Aseprite are required. If you only care about the Fairy type, you can use the icon I made for this guide, which is included in the resources folder as ",(0,s.jsx)(t.code,{children:"fairy_icon.png"})," as well as ",(0,s.jsx)(t.code,{children:"fairy_icon.rgcn"}),".\nYou could just replace the existing mystery type icon with the fairy type icon, but I recommend you create a new file for it instead. Have a look inside the ",(0,s.jsx)(t.code,{children:"pl_battle_obj"})," folder again. The last file should be ",(0,s.jsx)(t.code,{children:"0342.rnan"}),". Take your ",(0,s.jsx)(t.code,{children:".rgcn"})," file and name it something like ",(0,s.jsx)(t.code,{children:"0343.rgcn"})," (i.e. make sure the number is higher than the last file). Then use DSPRE to pack the folder back into a NARC file. Select the ",(0,s.jsx)(t.code,{children:"pl_battle_obj"})," folder and pack it into ",(0,s.jsx)(t.code,{children:"pl_batt_obj.narc"}),". After that replace the original ",(0,s.jsx)(t.code,{children:"pl_batt_obj.narc"})," in your ROM with the newly created one."]}),"\n",(0,s.jsxs)(t.p,{children:["Next we will need to tell the game to use the new type icon instead of the mystery type icon. To do this, we will need to modify the pointer to the type icon in battle. The game uses a table to determine which type icon to use for each type. This table is located at the offset ",(0,s.jsx)(t.code,{children:"0xF0AF0"})," in the ",(0,s.jsx)(t.code,{children:"arm9.bin"})," file of your ROM."]}),"\n",(0,s.jsxs)(t.p,{children:["Open ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents/arm9.bin"})," in your hex editor and navigate to the offset ",(0,s.jsx)(t.code,{children:"0xF0B14"}),". You should see ",(0,s.jsx)(t.code,{children:"EC 00 00 00"}),". This is the index of the type icon in the ",(0,s.jsx)(t.code,{children:"pl_batt_obj.narc"}),". Change this to the index of your new type icon. In this case, we will use ",(0,s.jsx)(t.code,{children:"57 01 00 00"})," which corresponds to index 343 (the index of the new fairy type icon we just created). Make sure to save the file after making this change."]}),"\n",(0,s.jsxs)(t.p,{children:["If you check it out in game, you will notice that the icon is using the wrong palette. This is because the game is still using the palette of the mystery type icon. To fix this, we will need to change the palette used by the type icon in battle. The game uses a table to determine which palette to use for each type icon. This table is located at the offset ",(0,s.jsx)(t.code,{children:"0xF0B4C"})," in the ",(0,s.jsx)(t.code,{children:"arm9.bin"})," file of your ROM."]}),"\n",(0,s.jsxs)(t.p,{children:["Open ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents/arm9.bin"})," in your hex editor and navigate to the offset ",(0,s.jsx)(t.code,{children:"0xF0B55"}),". You should see the byte ",(0,s.jsx)(t.code,{children:"02"}),". Change this to the palette index of your new type icon. In this case, we will use ",(0,s.jsx)(t.code,{children:"01"})," for the Fairy type which is the correct palette for the icon included in the resources folder.\nSave the file and test it in game. The icon should now display correctly in battle and in the summary screen."]}),"\n",(0,s.jsx)(t.h3,{id:"move-selection-palette",children:"Move Selection Palette"}),"\n",(0,s.jsxs)(t.p,{children:["Let's take care of the move selection palette next. This palette is used in battle when selecting a move and is located at the offset ",(0,s.jsx)(t.code,{children:"0x28C"})," in ",(0,s.jsx)(t.code,{children:"overlay/overlay_0011.bin"}),". Open this file in your hex editor and navigate to the offset ",(0,s.jsx)(t.code,{children:"0x28C"}),". You should see a series of bytes that look like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"cd 75 ff 7f 7a 5a 17 4e b5 45 72 3d 30 31 ed 28 cb 20 fb 66 c6 18 00 00 8c 31 5c 37 be 57 00 00\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This is the palette used for the mystery type. This one is a bit more tricky to edit. The resources folder contains a file called ",(0,s.jsx)(t.code,{children:"palette.pal"})," which contains the palette for the Fairy type, a file called ",(0,s.jsx)(t.code,{children:"move_selection_box.aseprite"})," which should help you get started with creating your own palette and a python script called ",(0,s.jsx)(t.code,{children:"palette_helper.py"})," which can help you convert a palette from JASC-Pal to the format used in the game and vice versa. If you wish you can use the palette I made for this guide, which is represented by the following bytes:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"CD 75 FF 7F 7C 66 17 52 18 56 1B 5E 35 41 F2 38 B2 34 DD 6E C6 18 00 00 8C 31 5C 37 BE 57 00 00\n"})}),"\n",(0,s.jsx)(t.h3,{id:"pok\xe9dex-type-icon",children:"Pok\xe9dex Type Icon"}),"\n",(0,s.jsxs)(t.p,{children:["The last thing we need to do is add the type icon to the Pok\xe9dex. This is the most annoying one to do since all the icons are stored as different animations that pull from a large cell graphic. The Pok\xe9dex icons are located in the ",(0,s.jsx)(t.code,{children:"/data/resource/eng/zukan/zukan.narc"})," file. Unpack this file to your workspace folder using DSPRE's NARC utility just like we did with the other type icon. To save you some pain the resource folder contains the required files for Fairy Type. If that's all you want to do, you can ",(0,s.jsx)(t.a,{href:"#packing-zukan-narc",children:"skip"})," the next section and just drag the provided files into the zukan folder, don't forget to pack the NARC again. If you want to learn how to add your own type icons, read on."]}),"\n",(0,s.jsxs)(t.p,{children:["You'll need the palette file ",(0,s.jsx)(t.code,{children:"0013.rlcn"})," and the cell graphic ",(0,s.jsx)(t.code,{children:"0090.rgcn"})," again, but this time we will also need the animation file ",(0,s.jsx)(t.code,{children:"0089.rnan"})," and the cell resource ",(0,s.jsx)(t.code,{children:"0088.recn"}),".\nDrag them all into Nitro Paint to open them. The cell graphic contains the actual sprite, the animation file contains the animation data and the cell resource contains the cell data that tells the game how to display the sprite. The .rgcn can be a bit hard to process visually, because frustratingly GF decided to throw in another unrelated and exceptionally large sprite at the end of the file. You'll also notice that the sorting of the cells is completely arbitrary, which will cause a ton of issues later since we will need to sort the cells by internal type ID. To save you having to painstakingly reorder the cells, the included ",(0,s.jsx)(t.code,{children:".rnan"})," file is already sorted. If you are planning to add your own type icons I suggest working with the provided files as a template. The template is already completely set up to work with the Fairy type, so the rest of this section explains the process on how you can recreate this on your own."]}),"\n",(0,s.jsxs)(t.p,{children:['We will need to add a new cell for the Fairy type icon. To do this, click on the "New Cell" cell button and save. This will create a new cell with the at the end of the list. Next have a look at the ',(0,s.jsx)(t.code,{children:".rgcn"}),' file. I recommend setting the width to 4 since it makes it easier to see the individual sprites. Click "Resize" and add 3 extra rows for a total size of 4 by 74. This will give us enough space to add the new type icon without overwriting any existing data. After that save the file.']}),"\n",(0,s.jsxs)(t.p,{children:["Next we will need to add the actual sprite. You can either create your own sprite or use the one I made for this guide, which is included in the resources folder as ",(0,s.jsx)(t.code,{children:"fairy_icon_pokedex.png"}),'.\nIn the Cell Editor, select the new cell you created and click "Generate Cell". You will be promted to select a sprite file. Select the ',(0,s.jsx)(t.code,{children:"fairy_icon_pokedex.png"}),' file and click "Open". In the generate cell dialog, make sure to select the ',(0,s.jsx)(t.strong,{children:"correct palette"})," (the one you used for the type icon). The provided icon uses ",(0,s.jsx)(t.strong,{children:"palette 3. Do not tick write palette"}),' as this will overwrite the palette used by the other type icons. Click "Complete" to create the cell. You should now see the new type icon in the cell editor. Make sure to save the cell resource after generating the cell.']}),"\n",(0,s.jsxs)(t.p,{children:['Next we\'ll need to add the new cell to the animation. Open the animation file in Nitro Paint. It should contain 17 existing animations, one for each type and one for the unrelated Pok\xe9dex sprite at the end. Click on the "New Sequence" button to append a new sequence. We now have enough space for all the icons. Next we will need to sort them according to the internal type ID. We will see exactly why later. Sequence 0 should be the yellow rectangle, having it be the first sequence is convenient for mapping the type IDs to the sequences later. The remaining sequences should be ordered according to the internal type ID, which is the same as the type ID used in the type chart (see ',(0,s.jsx)(t.a,{href:"#type-ids",children:"this"})," table). You can therefore double check that you have the right order by subtracting 1 from the sequence number and comparing it to the type ID. For example, sequence 1 should be the Normal type, which has the type ID 0 and so on. Since we are replacing the Mystery type with the Fairy type, sequence 10 should be the Fairy type icon."]}),"\n","\n",(0,s.jsxs)("div",{className:"image-container",children:[(0,s.jsx)("img",{src:h,alt:"Steps in Nitro Paint",width:1e3}),(0,s.jsx)("img",{src:d,alt:"Steps in Nitro Paint",width:1e3}),(0,s.jsx)("img",{src:c,alt:"Steps in Nitro Paint",width:300})]}),"\n",(0,s.jsx)("a",{id:"packing-zukan-narc"}),"\n",(0,s.jsxs)(t.p,{children:["Use DSPRE's NARC utility to pack the ",(0,s.jsx)(t.code,{children:"zukan"})," folder back into a NARC file. Select the ",(0,s.jsx)(t.code,{children:"zukan"})," folder and pack it into ",(0,s.jsx)(t.code,{children:"zukan.narc"}),". After that replace the original ",(0,s.jsx)(t.code,{children:"zukan.narc"})," in your ROM with the newly created one."]}),"\n",(0,s.jsx)(t.h3,{id:"modifying-the-games-code-to-show-the-pok\xe9dex-icon",children:"Modifying the game's code to show the Pok\xe9dex icon"}),"\n",(0,s.jsxs)(t.p,{children:["Since we completely resorted the sequences in the animation file, we will need to modify the game's code to make sure it uses the correct sequence for each type. In vanilla Platinum, the game uses a function that reads from a table to determine which sequence to use for each type. The function is located at offset ",(0,s.jsx)(t.code,{children:"0xE400"})," in the ",(0,s.jsx)(t.code,{children:"overlay_0021.bin"}),". Open this file in your hex editor and navigate to this offset. You should see a series of bytes that look like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"11 28 38 D8 01 18 79 44 ...\n"})}),"\n",(0,s.jsx)(t.p,{children:"Replace it (Ctrl + B in HxD) with the following bytes:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"01 30 70 47 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Instead of doing some complex mapping of the type IDs to the sequences, we simply add 1 to the type ID and use that as the sequence number. This is the reason we sorted the sequences to begin with.\nWe also need to tell the game where to find the yellow rectangle sprite (used in the backround of the Pok\xe9dex). Navigate to offset ",(0,s.jsx)(t.code,{children:"0xE514"}),". You should see ",(0,s.jsx)(t.code,{children:"11 21"})," replace with ",(0,s.jsx)(t.code,{children:"00 21"}),"."]}),"\n","\n",(0,s.jsxs)("div",{className:"image-container",children:[(0,s.jsx)("img",{src:p,alt:"Clefairy with Fairy type in battle",width:300,style:{verticalAlign:"top"}}),(0,s.jsx)("img",{src:y,alt:"Clefairy with Fairy type in summary",width:300,style:{verticalAlign:"top"}}),(0,s.jsx)("img",{src:u,alt:"Clefairy with Fairy type in Pok\xe9dex",width:300,style:{verticalAlign:"top"}})]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(t.p,{children:"At this point you should have a fully functional Fairy type in your game. You can test it by using a Pok\xe9mon with the Fairy type in battle and checking the Pok\xe9dex to see if the new icon is displayed correctly. If everything works as expected, congratulations! You have successfully added the Fairy Type to Platinum."}),"\n",(0,s.jsx)(t.h2,{id:"advanced-version",children:"Advanced Version"}),"\n",(0,s.jsxs)(t.p,{children:["The advanced version of this guide is meant for those who want to add ",(0,s.jsx)(t.strong,{children:"multiple new types to the game without replacing any existing type"}),". It is a more complex process that requires a rudimentary understanding of armips. You won't actually need to know how to write any ASM code, but you will need to know how to apply patches using armips. You will also need to know how to make minor edits to armips scripts as well as edit and run python scripts. The advanced version of this guide isn't actually independent from the lite version, so I recommend you read through the lite version first to get a better understanding of how the type chart works and how to add new types."]}),"\n",(0,s.jsx)(t.h3,{id:"tools-used-1",children:"Tools used:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"All the tools used in the lite version of this guide, plus:"}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/Kingcom/armips/releases",children:"armips"})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"As before make sure you have the ARM9 expansion patch applied to your ROM. If you don't have it, you can apply it using DSPRE's toolbox."}),"\n",(0,s.jsx)(t.li,{children:"Go ahead and repoint the move effect subscript table as described in the lite version of this guide. This is necessary to make space for the new type chart."}),"\n",(0,s.jsxs)(t.li,{children:["Modify the type chart to include your new types as described. If you're adding multiple new types, then don't even bother doing this manually, just use the ",(0,s.jsx)(t.code,{children:"type_chart_helper.py"})," script included in the resources folder."]}),"\n",(0,s.jsxs)(t.li,{children:["Make sure you have the ",(0,s.jsx)(t.code,{children:"armips"})," tool installed and available in your PATH. You can download it from ",(0,s.jsx)(t.a,{href:"https://github.com/Kingcom/armips/releases",children:"here"})]}),"\n",(0,s.jsxs)(t.li,{children:["Make sure you have ",(0,s.jsx)(t.code,{children:"python"})," installed and available in your PATH. On windows you can actually download it from the Microsoft Store, which is the easiest way to get it. I personally recommend setting up anaconda since it allows for easy management of python packages and environments, but this is not strictly necessary for this guide nor will it be covered here."]}),"\n",(0,s.jsx)(t.li,{children:"You'll need to make all the graphic assets for your new types. This includes the type icon, the Pok\xe9dex icon and the move selection palette. You can use the resources provided in the lite version of this guide as a starting point, but you will need to create your own assets for any other types you want to use."}),"\n",(0,s.jsx)(t.li,{children:"When inserting your sprites, make sure to take note of their indices in the respective NARC file / Cell Resource. You will need to use these indices in the armips script later on."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"setting-up-the-armips-script",children:"Setting up the armips script"}),"\n",(0,s.jsxs)(t.p,{children:["The armips script is used to modify the game's code to support the new types. You don't need to do any of the hex edits from the lite version as the script will do it for you. While it will also handle the repointing of the the move effect subscript table altough you will need to actually paste it at the defined offset yourself. The script is included in the resources folder as ",(0,s.jsx)(t.code,{children:"type_expansion_PLAT.asm"}),". Open it in an editor of your choice and have a look at it. You will need to make some changes to it before you can use it."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["First edit the ",(0,s.jsx)(t.em,{children:"GameFolder"})," variable to point to the folder where your unpacked ROM is located. This folder will usually be called something like ",(0,s.jsx)(t.code,{children:"platinum_DSPRE_contents"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Next edit the ",(0,s.jsx)(t.em,{children:"MoveEffectSubscriptOffset"})," variable to point to the offset where you want to paste the move effect subscript table. This should be the same offset you used when moving the table in the lite version of this guide. If you followed the guide, this should be ",(0,s.jsx)(t.code,{children:"0x1000"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["You will also need to specify the length of the move effect subscript table in the ",(0,s.jsx)(t.em,{children:"SubscriptLength"})," variable. This should be ",(0,s.jsx)(t.code,{children:"0x244"})," (the length of the table in bytes). By default, this is set to ",(0,s.jsx)(t.code,{children:"0x250"})," to make it a bit easier to identify the table in the hex editor, but you can change it to ",(0,s.jsx)(t.code,{children:"0x244"})," if you prefer."]}),"\n",(0,s.jsx)(t.li,{children:"(Side note: By changing this variable and putting new scripts in the right narc you can actually add more move effects to the game as well, but this is not covered in this guide.)"}),"\n",(0,s.jsxs)(t.li,{children:["Edit the ",(0,s.jsx)(t.em,{children:"SynthOverlayRelativeOffset"})," variable to point to an empty location in the synthetic overlay file. This one should be at an even offset before the offset you used for the move effect subscript table. This could be something like ",(0,s.jsx)(t.code,{children:"0xF00"}),". We will use this to hold some code that will handle the new types."]}),"\n",(0,s.jsxs)(t.li,{children:["You will need to specify the total amount of types in the ",(0,s.jsx)(t.em,{children:"TypeCount"})," variable. This should be the total amount of types including the existing types. For example, if you want to add the Fairy type and the Sound type, this should be ",(0,s.jsx)(t.code,{children:"20 = 18 (vanilla) + 2 (new)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"adding-new-types",children:"Adding new types"}),"\n",(0,s.jsxs)(t.p,{children:["The main part of the the script is the ",(0,s.jsx)(t.em,{children:"Tables"})," section at the bottom of the file. This is where you will tell the game where to look for your new icons and which palettes to use. This is also where you can define new palettes for the move selection box in battle. The script is already set up to handle the Fairy type, so you can use it as a template for your own types."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.em,{children:"MoveIconTable"})," contains the indices of the respective .rgcn files for the type icons in battle and summary screen. The indices are in the same order as the type IDs defined in the ",(0,s.jsx)(t.code,{children:"type_chart_helper.py"})," script (have a look at the enum at the top). For example, if you want to add the Sound type, you would add a new entry to this table with the index of your Sound type icon."]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.em,{children:"MoveIconPaletteTable"})," contains the indices of the palettes used by the type icons in battle and summary screen. The game always uses ",(0,s.jsx)(t.code,{children:"0074.rlcn"})," for the type icons, if you want custom palettes you will need to add it to this file."]}),"\n",(0,s.jsxs)(t.li,{children:["Just to make sure you don't go looking for it: There is no need to make changes to the Pok\xe9dex icon table. We just read the animation with the same ID as the type ID from ",(0,s.jsx)(t.code,{children:"0090.rnan"}),". If you correctly added the animation and associated graphics using Nitro Paint the game will take care of the rest."]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.em,{children:"MoveSelectionPaletteTable"})," contains the addresses of the palettes used by the move selection box in battle."]}),"\n",(0,s.jsxs)(t.li,{children:["Finally, you can define the actual palettes used by the ",(0,s.jsx)(t.em,{children:"MoveSelectionPaletteTable"}),". Make sure to define the addresses of any new palettes up top in the ",(0,s.jsx)(t.em,{children:"AdressDefinitions"})," section. You can ",(0,s.jsx)(t.strong,{children:"and should(!)"})," use the ",(0,s.jsx)(t.code,{children:"palette_helper.py"})," script to convert your palette from JASC-Pal format to the format used in the game. This way you can use Aseprite to create your palettes and then convert them to the format used in the game."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"assigning-new-types-to-moves-and-pok\xe9mon-1",children:"Assigning new types to moves and Pok\xe9mon"}),"\n",(0,s.jsx)("a",{id:"assigning-new-types-2"}),"\n",(0,s.jsx)(t.p,{children:'Unlike before we need to to a bit of extra work so that DSPRE actually knows about the new types. Open up Text Archive 624 in DSPRE. Append a new line to the end of the file with the name of your new type. For example, if you want to add the Fairy and Sound type, you would add a new line with the name "FAIRY" and one named "SOUND". The message number in this file is actually what DSPRE uses to determine the type ID, so make sure to add them in the correct order or everything will break. Also make sure not to remove any lines from this file, unless there are no Pok\xe9mon or moves that use the type you are removing. If you don\'t do this, DSPRE will crash the next time you try to open the Pok\xe9mon or Move Editor.'}),"\n",(0,s.jsx)(t.h2,{id:"not-yet-covered-in-this-guide",children:"Not (yet) covered in this guide"}),"\n",(0,s.jsx)(t.p,{children:"As of right now, this guide does not yet cover:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Adding the new types to the Move Tester Pok\xe9tch app"}),"\n",(0,s.jsx)(t.li,{children:"Adding the new types to the TV related menus"}),"\n",(0,s.jsx)(t.li,{children:"Adding new types to hidden power (vanilla did not actually implement hidden power fairy so this is not strictly necessary)"}),"\n",(0,s.jsx)(t.li,{children:"Adding new types to natural gift"}),"\n",(0,s.jsx)(t.li,{children:"Adding new type boosting items (e.g. Pixie Plate, Sound Plate, etc.)"}),"\n",(0,s.jsx)(t.li,{children:"Adding new Arceus forms for the new types\nI may cover these topics in a future update to this guide, but they aren't a priority right now. I suspect that expanding Arceus forms will be particularly difficult, so I may not cover it at all."}),"\n"]})]})}function j(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(w,{...e})}):w(e)}}}]);