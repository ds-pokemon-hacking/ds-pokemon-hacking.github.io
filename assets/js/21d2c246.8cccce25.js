"use strict";(self.webpackChunkkodsh_wiki_new=self.webpackChunkkodsh_wiki_new||[]).push([[1647],{85734:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"generation-iv/guides/hgss-code_injection/hgss-code_injection","title":"Code Injection","description":"Author(s): BluRose.","source":"@site/docs/generation-iv/guides/hgss-code_injection/hgss-code_injection.md","sourceDirName":"generation-iv/guides/hgss-code_injection","slug":"/generation-iv/guides/hgss-code_injection/","permalink":"/docs/generation-iv/guides/hgss-code_injection/","draft":false,"unlisted":false,"editUrl":"https://github.com/ds-pokemon-hacking/ds-pokemon-hacking.github.io/docs/generation-iv/guides/hgss-code_injection/hgss-code_injection.md","tags":[{"inline":true,"label":"Guide (HeartGold)","permalink":"/docs/tags/guide-heart-gold"},{"inline":true,"label":"Guide (SoulSilver)","permalink":"/docs/tags/guide-soul-silver"}],"version":"current","frontMatter":{"title":"Code Injection","tags":["Guide (HeartGold)","Guide (SoulSilver)"]},"sidebar":"generation_iv_sidebar","previous":{"title":"Guides","permalink":"/docs/category/guides"},"next":{"title":"Adding New Overworlds in HeartGold Engine","permalink":"/docs/generation-iv/guides/hgss-new_overworlds/"}}');var o=n(74848),s=n(28453);const r={title:"Code Injection",tags:["Guide (HeartGold)","Guide (SoulSilver)"]},a="Code Injection",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Manual Process",id:"manual-process",level:2},{value:"Shortcomings of the Manual Process",id:"shortcomings-of-the-manual-process",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"<code>hooks</code>",id:"hooks",level:3},{value:"<code>bytereplacement</code>",id:"bytereplacement",level:3},{value:"<code>routinepointers</code>",id:"routinepointers",level:3},{value:"<code>repoints</code>",id:"repoints",level:3},{value:"Code Injection Template",id:"code-injection-template",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"code-injection",children:"Code Injection"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["Author(s): ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie",children:"BluRose"}),".\r\nResearch: ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie",children:"BluRose"}),", Touched, and ",(0,o.jsx)(t.a,{href:"https://github.com/Skeli789/",children:"Skeli"})," for the original GBA scripts."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This is an overall code injection guide and explanation behind the code injection framework for HeartGold and SoulSilver.  The template repository can be easily adapted to the rest of the Gen 4 games as long as there is a synthetic overlay definition."}),"\n",(0,o.jsxs)(t.p,{children:["Assembly will not be covered here.  It is recommended you understand assembly code and just basic coding in general before reading this.  There are plenty of tutorials out there for this.  One focused on the NDS that somewhat assumes any programming knowledge (which you'd need to know to inject code you've written to begin with) is Mikelan's overview which can be downloaded ",(0,o.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(46014).A+"",children:"here"}),"."]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#manual-process",children:"Manual Process"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#shortcomings-of-the-manual-process",children:"Shortcomings of the Manual Process"})}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"#implementation-details",children:"Implementation Details"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#hooks",children:(0,o.jsx)(t.code,{children:"hooks"})})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#bytereplacement",children:(0,o.jsx)(t.code,{children:"bytereplacement"})})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#routinepointers",children:(0,o.jsx)(t.code,{children:"routinepointers"})})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#repoints",children:(0,o.jsx)(t.code,{children:"repoints"})})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#code-injection-template",children:"Code Injection Template"})}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"manual-process",children:"Manual Process"}),"\n",(0,o.jsx)(t.p,{children:"The Nintendo DS has 4 MB of EWRAM.  Unlike the GBA, the ROM is not directly mapped and readable in memory.  Files must be dumped into that 4 MB of memory in order to be accessed.  This includes all code that is run--the processor CPU's don't have direct access to the ROM in code execution space."}),"\n",(0,o.jsx)(t.p,{children:"The way that was strongarmed by Nintendo onto developers is an overlay system.  This supports swapping out code as it is needed, but statically:  the overlays are not relocatable.  Special care must be taken to define game states, what code is all needed, and when it is needed."}),"\n",(0,o.jsx)(t.p,{children:"The idea behind code injection is that the normal code execution is highjacked and brought to our code.  The ARM9 binary is constantly loaded in to the memory as something that is constant, and largely includes code that is common between every situation possible."}),"\n",(0,o.jsxs)(t.p,{children:["The way you'd typically go about this is by manually assembling instructions using an assembler like ",(0,o.jsx)(t.code,{children:"as"})," of the GNU ",(0,o.jsx)(t.code,{children:"arm-none-eabi"})," toolset.  This then gives us an output binary that we can paste somewhere using something like ",(0,o.jsx)(t.a,{href:"https://pokehacking.com/tutorials/ramexpansion/",children:"Mikelan's synthetic overlay implementation"}),", which gives a file that can be used to load in code that serves as an extension of the existing code memory regions."]}),"\n",(0,o.jsxs)(t.p,{children:["An example of this in action is in the code edits by ",(0,o.jsx)(t.a,{href:"https://twitter.com/AdAstra_GL",children:"AdAstraGL"})," to ",(0,o.jsx)(t.a,{href:"https://pastebin.com/eCvYDcyw",children:"speed up the HP bar in HeartGold and Platinum"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"1) Paste this at 0x14FF0 of your synthetic overlay file:\r\n       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\r\n\r\n0000   2D 2D 48 50 20 42 41 52 20 53 50 45 45 44 2D 2D   --HP BAR SPEED--\r\n0010   80 21 49 00 48 43 11 1C 70 47 C0 46 FF FF FF FF   \u20ac!I.HC..pG\xc0F\xff\xff\xff\xff\r\n\r\n2) Paste this at offset 0x2E17A of an uncompressed overlay12.\r\n77 F1 D1 FA\n"})}),"\n",(0,o.jsxs)(t.p,{children:["From the synthetic overlay, the code is dumped to 0x023C8000 in the EWRAM (as implemented by Mikelan).  This places the data we just wrote at ",(0,o.jsx)(t.code,{children:"0x023C8000 + 0x14FF0 = 0x023DCFF0"})," in the EWRAM."]}),"\n",(0,o.jsxs)(t.p,{children:["Overlay 12 is loaded in at 0x022378C0 in EWRAM.  The code at 0x2E17A of overlay 12 is at ",(0,o.jsx)(t.code,{children:"0x022378C0 + 0x2E17A = 0x02265A3A"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Dumping Overlay 12 into IDA Pro and making an IDB (or using the one from the IDB's that I maintain ",(0,o.jsx)(t.a,{href:"https://mega.nz/folder/nuhlULbZ#6nbkKtNLXAkTndcRAVtltA",children:"here"})," ) will give this as the code dump near that area:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(31085).A+"",width:"834",height:"330"})}),"\n",(0,o.jsxs)(t.p,{children:["The code at ",(0,o.jsx)(t.code,{children:"0x02265A3A"})," is the code that is already run (because it's in the game's code already), so we start from there.  The instruction there is changed to this:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(86477).A+"",width:"754",height:"314"})}),"\n",(0,o.jsxs)(t.p,{children:["This jumps directly to the code that we just inserted at ",(0,o.jsx)(t.code,{children:"0x023DCFF0"}),"--the second line at ",(0,o.jsx)(t.code,{children:"0x023DD000"}),", to be exact."]}),"\n",(0,o.jsxs)(t.p,{children:["From there, the code at ",(0,o.jsx)(t.code,{children:"0x023DD000"})," (as dumped by REBot in KoDSH):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-arm",children:"movs r1, #0x80   ; +0 = 80 21\r\nlsls r1, r1, #1  ; +2 = 49 00\r\nmuls r0, r1, r0  ; +4 = 48 43\r\nadds r1, r2, #0  ; +6 = 11 1c\r\nbx   lr          ; +8 = 70 47\r\nmov  r8, r8      ; +10 = c0 46\n"})}),"\n",(0,o.jsx)(t.p,{children:"As AdAstra explains in the tutorial, this allows for a coarser control that isn't just a multiplier on the original speed of the HP bar (when it's depleting).  As it introduces more instructions in place of the older set, there is a need for space elsewhere to insert this bit of code."}),"\n",(0,o.jsxs)(t.p,{children:["The first line inserted--literally ",(0,o.jsx)(t.code,{children:"--HP BAR SPEED--"})," in ASCII--is just a marker that they insert to help you keep track of what in your synthetic overlay is already managed."]}),"\n",(0,o.jsx)(t.h2,{id:"shortcomings-of-the-manual-process",children:"Shortcomings of the Manual Process"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Note that this is not a diss or anything on AdAstra and/or his tutorial."}),"  This is just a presentation to describe the process that we are looking to automate for code injection."]}),"\n",(0,o.jsx)(t.p,{children:"Manual insertion of this is tedious.\r\nThe manual insertion process also mandates that you keep track of things in your synthetic overlay as it fills up--which is where that marker comes in as a reminder when the user is scrolling through their code binaries and forgets what each bit of otherwise-meaningless hexadecimal is.\r\nSharing this with other people places this smack-dab in the middle of their synthetic overlays and cuts down on continuous free space that they may want to use for other things.  It will require reverse engineering to move this elsewhere, if they even remember the change in the game code that redirected execution out to this point."}),"\n",(0,o.jsx)(t.p,{children:"The idea with code injection frameworks is to cut down on the manual hex editing and allow code to be shared for insertion at any point in code expansion areas--wherever there is free memory at any given point."}),"\n",(0,o.jsx)(t.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,o.jsx)(t.p,{children:"When assembling and compiling code, an object file is produced.  This can then be linked to specific addresses to create a linked object of a number of direct compiled objects that are all together.  We can view these addresses, parse the symbol output with Python, and correlate it with our own custom format (also parsed by Python) that will fully automate the overlay process for us--all we have to edit is the code."}),"\n",(0,o.jsxs)(t.p,{children:["This does not eliminate the reverse engineering step required to ",(0,o.jsx)(t.em,{children:"find"})," exactly where to branch out of the game code to our code.  There is no tutorial for that--you just have to get into the weeds of the assembly directly and figure out what each piece of code is doing.  This is where the GDB Debugger in Desmume coupled with IDA Pro or Ghidra is useful--you can see exactly what is executing and when, trace it to identify what you need to do."]}),"\n",(0,o.jsx)(t.h3,{id:"hooks",children:(0,o.jsx)(t.code,{children:"hooks"})}),"\n",(0,o.jsx)(t.p,{children:"The method chosen to decide how to highjack the game's execution is by writing hooks in the binary automatically based on a text file we create and parse.  The hook code is designed to be generic:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-arm",children:"ldr rN, =functionOffset\r\nbx rN\r\n.pool\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We can insert C code to replace entire functions this way.  In this example, we'll use ",(0,o.jsx)(t.code,{children:"PocketCompaction"})," from hg-engine's ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-engine/blob/main/src/bag.c",children:(0,o.jsx)(t.code,{children:"src/bag.c"})}),".  We know this is an equivalent implementation due to the ",(0,o.jsx)(t.a,{href:"https://github.com/pret/pokeheartgold/blob/master/src/bag.c#L280",children:"pokeheartgold decompiled code"}),".:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"void PocketCompaction(ITEM_SLOT *slots, u32 count) {\r\n    u32 i, j;\r\n    for (i = 0; i < count - 1; i++) {\r\n        for (j = i + 1; j < count; j++) {\r\n            if (slots[i].quantity == 0) {\r\n                SwapItemSlots(&slots[i], &slots[j]);\r\n            }\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"This gives an 8-byte snippet of assembly (or 10 bytes if not 4-byte word aligned, which is automatically accounted for) that allows us to jump from any point in EWRAM to any other point in EWRAM."}),"\n",(0,o.jsx)(t.p,{children:"The hook format as implemented is as follows:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"# overlayId symbolName memAddress regId\r\n# i.e.\r\n\r\narm9 PocketCompaction 080785A0 2\r\n0001 FUN_ReadEntryDataArc 021FB164 3\n"})}),"\n",(0,o.jsxs)(t.p,{children:["If the ",(0,o.jsx)(t.code,{children:"memAddress"})," starts with ",(0,o.jsx)(t.code,{children:"08"}),", the hook is inserted at the direct file offset of the uncompressed binary, i.e. directly at ",(0,o.jsx)(t.code,{children:"memAddress & 0xFFFFFF"}),".  If the ",(0,o.jsx)(t.code,{children:"memAddress"})," starts with ",(0,o.jsx)(t.code,{children:"02"}),", it is understood as an address in EWRAM, and the NDS overlay table is read to determine where ",(0,o.jsx)(t.code,{children:"overlayId"})," is loaded in so that the code binary can be written to."]}),"\n",(0,o.jsxs)(t.p,{children:["Here, the arm9 ",(0,o.jsx)(t.code,{children:"memAddress"})," entry for ",(0,o.jsx)(t.code,{children:"PocketCompaction"})," starts with ",(0,o.jsx)(t.code,{children:"08"})," so the arm9 binary is opened and the hook is directly inserted at file offset ",(0,o.jsx)(t.code,{children:"0x785A0"}),".  Then overlay 1 is opened and ",(0,o.jsx)(t.code,{children:"memAddress"})," starts with ",(0,o.jsx)(t.code,{children:"02"})," so the script knows that this is a memory offset.  It parses the overlay table (in y9.bin), sees that overlay 1 starts at ",(0,o.jsx)(t.code,{children:"0x021E5900"}),", and inserts a hook at the file offset ",(0,o.jsx)(t.code,{children:"0x021FB164 - 0x021E5900 = 0x15864"})," of overlay 1."]}),"\n",(0,o.jsxs)(t.p,{children:["After compiling a C file or assembling an assembly file, a compiled object is output.  A compiled object can be passed through a linker (here the standard ",(0,o.jsx)(t.code,{children:"ld"}),") to produce a linked object."]}),"\n",(0,o.jsxs)(t.p,{children:["The direct output of ",(0,o.jsx)(t.code,{children:"nm linked_object.o"})," gives the addresses of all the functions and data inside of ",(0,o.jsx)(t.code,{children:"linked_object.o"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"023d88cf T PocketCompaction\r\n023d873d T Pocket_GetItemSlotForAdd\r\n023dcbf0 T Pocket_GetItemSlotForAdd_hook\r\n023dcc08 t Pocket_GetItemSlotForAdd_return_address\r\n023d87c9 T Pocket_GetItemSlotForRemove\r\n023dcc60 T Pocket_GetItemSlotForRemove_hook\r\n023dcc78 t Pocket_GetItemSlotForRemove_return_address\r\n023d88ab T Pocket_GetQuantity\r\n023d891d T Pocket_TakeItem\r\n023dccb4 T Pocket_TakeItem_hook\r\n023dcccc t Pocket_TakeItem_return_address\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We use Python to parse this output from ",(0,o.jsx)(t.code,{children:"nm"}),' and create a "symbol table" of sorts that shows where code we put in the ROM will eventually be loaded into the EWRAM.  We can finally use all of this to write the hooks directly.']}),"\n",(0,o.jsxs)(t.p,{children:["In this example, the ",(0,o.jsx)(t.code,{children:"PocketCompaction"})," function is seen at ",(0,o.jsx)(t.code,{children:"023D88CF"})," in the EWRAM, so the code below is written to ",(0,o.jsx)(t.code,{children:"0x785A0"})," of the arm9 binary (as specified by ",(0,o.jsx)(t.code,{children:"080785A0"})," in the hook entry):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-arm",children:"ldr r2, =0x023D88CF // PocketCompaction's offset in memory\r\nbx r2\r\n.pool // gets expanded to CF 88 3D 02 as it stores the ldr value above\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Which automatically puts ",(0,o.jsx)(t.code,{children:"00 4A 10 47 CF 88 3D 02"})," at ",(0,o.jsx)(t.code,{children:"0x785A0"})," of the arm9 binary.  This highjacks the code execution directly to our version of ",(0,o.jsx)(t.code,{children:"PocketCompaction"}),", effectively ",(0,o.jsx)(t.em,{children:"replacing the function entirely with whatever code we write"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"You do not need to replace an entire function at its start.  You can branch out of the middle of a function, write purely assembly code to tweak a register's value, or write a custom hook as a landing pad from the code binary to tweak certain registers and restore values before passing everything back to the game to run proper."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Note for functions that have more than 3 arguments:  The C standard for ARM stipulates that arguments 0-3 are passed as ",(0,o.jsx)(t.code,{children:"r0"}),"-",(0,o.jsx)(t.code,{children:"r3"})," in the resulting assembly.  Further arguments are passed via the stack.  To deal with this, we write a custom hook including some ",(0,o.jsx)(t.code,{children:"bytereplacement"})," elements that maintains all of the registers and stack pointer going into the function from the ROM.  See the ",(0,o.jsxs)(t.a,{href:"https://github.com/search?q=repo%3ABluRosie%2Fhg-engine%20CantEscape&type=code",children:[(0,o.jsx)(t.code,{children:"CantEscape"})," example"]})," for implementation details."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Further convenience is afforded in these files that Python parses with ",(0,o.jsx)(t.code,{children:"bytereplacement"}),", ",(0,o.jsx)(t.code,{children:"routinepointers"}),", and ",(0,o.jsx)(t.code,{children:"repoints"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"bytereplacement",children:(0,o.jsx)(t.code,{children:"bytereplacement"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"bytereplacement"})," writes a stream of bytes to an offset specified in the code binary of the ROM (with the same ",(0,o.jsx)(t.code,{children:"08"}),"/",(0,o.jsx)(t.code,{children:"02"})," file offset/memory offset handling):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"# pokewalker species limiters\r\n0112 021ED63C FF 7F 00 00\r\n0112 021ED668 FF 7F 00 00\r\n0112 021EFB10 FF 7F 00 00\r\n0112 021F126C FF 7F 00 00\r\n0112 021F323C FF 7F 00 00\r\n\r\n#Binding moves 1/8th\r\n0012 08012852 08\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Here, overlay 112 has a number of memory offsets overwritten with ",(0,o.jsx)(t.code,{children:"FF 7F 00 00"}),".  All of these files take lines that start with ",(0,o.jsx)(t.code,{children:"#"})," as comments that can be discarded (outside of ",(0,o.jsx)(t.code,{children:"#ifdef"})," conditional inclusion).\r\nOverlay 12 has ",(0,o.jsx)(t.code,{children:"08"})," directly written to file offset ",(0,o.jsx)(t.code,{children:"0x12852"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"routinepointers",children:(0,o.jsx)(t.code,{children:"routinepointers"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"routinepointers"})," will place a pointer to a function at an offset specified in the code binary of the ROM (with the same ",(0,o.jsx)(t.code,{children:"08"}),"/",(0,o.jsx)(t.code,{children:"02"})," file offset/memory offset handling).  This automatically accounts for thumb if it is compiled as such--the offset written will have 1 added to it if necessary."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"0012 BGCallback_Waza_Extend 08037084\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This places a pointer to the code symbol ",(0,o.jsx)(t.code,{children:"BGCallback_Waza_Extend"})," at file offset ",(0,o.jsx)(t.code,{children:"0x37084"})," of overlay 12.  This is automatically adjusted for thumb mode if necessary."]}),"\n",(0,o.jsx)(t.h3,{id:"repoints",children:(0,o.jsx)(t.code,{children:"repoints"})}),"\n",(0,o.jsxs)(t.p,{children:["And ",(0,o.jsx)(t.code,{children:"repoints"})," will place a pointer to any data you specify in the code in the code binary of the ROM (with the same ",(0,o.jsx)(t.code,{children:"08"}),"/",(0,o.jsx)(t.code,{children:"02"})," file offset/memory offset handling):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"# repoint the type effectiveness table\r\n0012 TypeEffectivenessTable+1 02251D20\r\n0012 TypeEffectivenessTable+2 02251D24\r\n0012 TypeEffectivenessTable 0225204C\r\n0012 TypeEffectivenessTable 02252174\r\n0012 TypeEffectivenessTable+1 022521C0\r\n0012 TypeEffectivenessTable+2 022521C4\r\n0012 TypeEffectivenessTable 02252640\r\n0012 TypeEffectivenessTable+1 02252644\r\n0012 TypeEffectivenessTable+2 02252648\r\n0012 TypeEffectivenessTable 02252694\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"repoints"})," is unique in that it lets you specify an offset to be added to the pointer before writing it to the code binaries.  This is done to mimic how the compiler handles optimizations at times by inserting a reference to a table that is offset by the position of the entry it needs."]}),"\n",(0,o.jsxs)(t.p,{children:["In this example, ",(0,o.jsx)(t.code,{children:"TypeEffectivenessTable"})," is a list of ",(0,o.jsx)(t.code,{children:"u8"})," arrays with declaration ",(0,o.jsx)(t.code,{children:"u8 TypeEffectivenessTable[][3];"}),".  Each 3 bytes is in the order of attacking type, defending type, and effectiveness multiplier.  Code that only references the effectiveness multiplier may be optimized by the compiler to directly build that offset into the reference it generates (and does), so we allow the option to compensate for that here."]}),"\n",(0,o.jsxs)(t.p,{children:["It is also possible to use functions and data from the ROM itself.  The code injection framework achieves this by defining symbol offsets in ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-transparent-textbox/blob/main/rom.ld",children:(0,o.jsx)(t.code,{children:"rom.ld"})}),".  Here we can add a function from the ROM, say ",(0,o.jsx)(t.code,{children:"DaycareMon_GetBoxMon"})," which according to the ",(0,o.jsx)(t.a,{href:"https://raw.githubusercontent.com/pret/pokeheartgold/xmap/heartgoldus.xMAP",children:(0,o.jsx)(t.code,{children:"xmap"})})," is located at ",(0,o.jsx)(t.code,{children:"020292E4"})," in the arm9.  To use this, we add an entry to ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-transparent-textbox/blob/main/rom.ld",children:(0,o.jsx)(t.code,{children:"rom.ld"})}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"DaycareMon_GetBoxMon = 0x020292E4 | 1;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"0x020292E4"})," is the base offset of the function.  The ",(0,o.jsx)(t.code,{children:"| 1"})," is due to the function being in thumb mode (as most functions from the ROM are), a reduced instruction set of ARM that permits much smaller code generation."]}),"\n",(0,o.jsxs)(t.p,{children:["To then call this in our code, we have to add a declaration of the function (its structures, ",(0,o.jsx)(t.code,{children:"BoxPokemon"})," and ",(0,o.jsx)(t.code,{children:"DaycareMon"})," will have to be copied as well):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"BoxPokemon *DaycareMon_GetBoxMon(DaycareMon *dcmon);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["When we do this alone, the linker assumes the function is ARM and resolves the address of the function to be ",(0,o.jsx)(t.code,{children:"0x020292E4"}),", jumping to it with a ",(0,o.jsx)(t.code,{children:"blx"})," instruction to swap the instruction set to ARM which will likely cause a crash.  To fix this, we introduce the ",(0,o.jsx)(t.code,{children:"long_call"})," compilation attribute:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"BoxPokemon * __attribute__((long_call)) DaycareMon_GetBoxMon(DaycareMon *dcmon);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This tricks the compiler to elicit code that will not cull the thumb bit from the function address and properly jump to it.  You can define this as a macro, i.e. ",(0,o.jsx)(t.code,{children:"LONG_CALL"}),", which would allow this declaration to look like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-c",children:"#define LONG_CALL __attribute__((long_call))\r\n...\r\nBoxPokemon * LONG_CALL DaycareMon_GetBoxMon(DaycareMon *dcmon);\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"DaycareMon_GetBoxMon"})," can then be used in the code that you write as any other function.  The linker will resolve its address properly and the code will function as it is in the original ROM.  This is useful for copying existing functions from the ROM without needing to copy copious amounts of code from the decompilations or manually reimplement in assembly."]}),"\n",(0,o.jsx)(t.h2,{id:"code-injection-template",children:"Code Injection Template"}),"\n",(0,o.jsxs)(t.p,{children:["For those who don't want to fully overhaul the battle system of their hacks, the ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-transparent-textbox",children:"repository for transparent textboxes"})," serves as a template for code injection.  It still uses ",(0,o.jsx)(t.a,{href:"https://pokehacking.com/tutorials/ramexpansion/",children:"Mikelan and Nomura's synthetic overlay approach"})," to code expansion, where an unused file in the file system is repurposed as a code storage container instead of directly using another overlay as is necessary for larger code injection projects with sizes that surpass the RAM size limitations afforded by this approach.  It is still completely valid for entire projects--0x18000 bytes is quite a lot, and anything but entire engine overhauls is supported by this."]}),"\n",(0,o.jsxs)(t.p,{children:["Its ",(0,o.jsx)(t.code,{children:"Makefile"})," has an example of a NARC being edited with files that are present in the repository.  ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-transparent-textbox/blob/main/Makefile#L87",children:"These"})," ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-transparent-textbox/blob/main/Makefile#L97-L106",children:"lines"})," (there are two links there, lines 87 and 97-106) can be deleted in the event that you don't want to use the transparent textboxes that are implemented by the repository.  This will then also involve deleting the code that is present to handle the transparent textboxes--clearing out the ",(0,o.jsx)(t.code,{children:"src"})," directory and the ",(0,o.jsx)(t.code,{children:"asm/other_hooks.s"}),", ",(0,o.jsx)(t.code,{children:"repoints"}),", ",(0,o.jsx)(t.code,{children:"bytereplacement"}),", and ",(0,o.jsx)(t.code,{children:"hooks"})," files will leave the repository blank for your populating."]}),"\n",(0,o.jsxs)(t.p,{children:["From there, adding new files in ",(0,o.jsx)(t.code,{children:"src"})," will automatically compile them and link everything for insertion.  Same goes for assembly source files in ",(0,o.jsx)(t.code,{children:"asm"}),".  ",(0,o.jsx)(t.a,{href:"https://github.com/BluRosie/hg-transparent-textbox/blob/main/asm/thumb_help.s",children:(0,o.jsx)(t.code,{children:"asm/thumb_help.s"})})," is a file that implements some functions that the C compiler sometimes assumes exists and uses as functions."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},46014:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/files/asm1-dfe448d0629040cb8da4ced54a0ed182.pdf"},31085:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/loc_2265A36-9b1d03f18d2f212379a0161f2c3190fe.png"},86477:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/loc_2265A36_edited-606ee1475b3c9c479f91cf6f461b7e14.png"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(96540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);